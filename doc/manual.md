# Requirements

All DBGeni needs to run is the [Ruby](http://ruby-lang.org) programming language and the [RubyGems](http://rubygems.org/) package manager. No knowledge of Ruby is required to use it, but you need to install it.

Depending on what database you want to use, you will also need the drivers for that database.

## SQLite

 * Install the sqlite3 Gem.
 * The sqlite3 shell is required and must be on your path. Get it from [the sqlite website](http://www.sqlite.org/download.html)

## Oracle

 * Install the Oracle Client and ensure sqlplus works and is on your path 
 * Install [ruby-oci8](http://ruby-oci8.rubyforge.org/en/)


# Download

Download the [DBGeni GEM](/foobar)

# Install

    $ gem install dbgeni-0.1.0.gem

If Ruby is on your path, then the dbgeni command should display the usage instructions:

    $ dbgeni --help

# Default Setup

DBGeni requires a config file containing database connection details and the location in which all the migration scripts are stored.

If you are creating a new project, the new command will create a directory structure and a skeleton config file:

    $ dbgeni new /path/to/new_project

This will create a directory structure as follows:

    /path/to/new_project            # Project Directory
    /path/to/new_project/.dbgeni    # Config file
    /path/to/new_project/migrations # Directory to hold migrations

By default a new SQLite database will be used, so it is safe to play around.

If you just want to create a skeleton config file in the an existing project, use the new-config command:

    $ dbgeni new-config /path/to/config/.dbgeni

# The Config File

The skeleton config file generated by the new or new-config commands is given below:


    # Parameters Section
    #
    # This directory specifies the location of the migrations directory
    migrations_directory "./migrations"
    
    # This specifies the type of database this installer is applied against
    # Valid values are oracle, sqlite however this is not validated at runtime
    # Default is sqlite
    database_type "sqlite"
    
    # This is the table the installer logs applied migrations in the database
    # The default is dbgeni_migrations
    database_table "dbgeni_migrations"
    
    # Environment Section
    #
    # There must be at least one environment, and at a minimum each environment
    # should define a username, database and password, except SQLite which only 
    # requires a database.
    #
    # Typically there will be more than one enviroment block detailing development,
    # test and production but any number of environments are valid provided there is at least one.
    
    environment('development') {
      database 'devdb.sqlite' # this must be here, or it will error. For Oracle, this is the TNS Name
    #   username ''            # this must be here, or it will error
    #   password ''            # If this value is missing, it will be promoted for if the env is used.
    #
    #   Other parameters can be defined here and will override global_parameters
    #   param_name 'value'
    }
    
    #
    # environment('test') {
    #   username 'user'         # this must be here, or it will error
    #   database 'testdb.sqlite # this must be here, or it will error. For Oracle, this is the TNS Name
    #   password ''             # If this value is missing, it will be promoted for if the env is used.
    # }

There are two sections.

## Parameter Section

This contains parameters which tell dbgeni where to find migrations, which database table to use and what sort of database it should connect to.

## Environment Section

This contains details about each environment dbgeni can connect to. In this release, the only useful parameters are database, username and password. In future releases other parameters can be defined here and used as parameters in SQL scripts.

There can be many environment definitions, but each should have a unique name. The idea is to create an environment section for each database you want to apply migrations against. An environment is defined using the syntax below:

    environment('<name>') {
      username 'user'
      password 'pass'
      database 'sqlite_file or Oracle TNS name'
    }

If there is only 1 environment, then dbgeni will use it as the default. If there are many environments, then you must specify which environment to use using the --environment-name switch (-e for short), eg:

    $ dbgeni migrations applied --environment-name test

## Default Filename

By default, the config file is called .dbgeni If you run the dbgeni command it looks for a file called .dbgeni in the current directory, and if it does not find it, it will error:

    $ dbgeni migrations list
    The config file ./.dbgeni does not exist:  (expanded from ./.dbgeni) does not exist

If the config file is located elsewhere or does not have the default name, it must be specified with the --config-file switch (-c for short).


# Initialize the Database

Before most of the dbgeni commands can be used, the target database must be initialized. This simply creates a table in the database, with the default name of dbgeni_migrations having the following structure:

    create table dbgeni_migrations
    (
      sequence_or_hash varchar2(1000) not null,
      migration_name   varchar2(4000) not null,
      migration_type   varchar2(20)   not null,
      migration_state  varchar2(20)   not null,
      start_dtm        date,
      completed_dtm    date
    )

If the database\_table parameter has been change in the config file, it will override the default name.

If you attempt to run a command against an uninitialized database, dbgeni will error:

    TODO - not initialized error.

The best way to initialize the database is using the initialize command:

    $ dbgeni initialize

    info - Database initialized successfully

Alternatively create the table structure given above manually.


# Generating Migrations

For dbgeni to recognise migrations, they must be stored in the "migrations_directory" and named in a specific way:

    <TIMESTAMP>_<UP/DOWN>_<NAME>.sql

 * TIMESTAMP is the current date and time in the format YYYYMMDDHH24MI
 * UP/DOWN indicates if the script is used to move the database forward a version or rollback a version
 * NAME is a name that describes the migration.

Migrations should always be created in pairs, with both an UP and a DOWN script, eg:

    201108101531_up_create_users.sql
    201108101531_down_create_users.sql

A dbgeni command can be used to create the pair of empty migration files with the current timestamp:

    $ dbgeni generate migration create_users_table

Before the migrations can be applied to the database, the empty files should be edited to contain some definition or data changes. If migration is applied when the files are empty, dbgeni will not error.

There is no special syntax for the code in the migration files - any SQL that is valid to run against the target database can be included.

Edit the 'up' file and add some DDL code, eg:

    create table users (
      id integer,
      username varchar2(255)
    );

Edit the down file and add the equivalent drop statement, eg:

    drop table users;

This migration is now in a state that it can be applied to the target database.

# Migration Commands

The migration command has several sub-commands to list, apply and rollback migrations. For all migration commands the --environment-name (-e) and --config-file (-c) switches can be used if necessary.

## List Migrations

To list all migrations stored in the migration directory, use the list sub-command:

    $ dbgeni migrations list

## Applied Migrations

To see all the migrations that have been applied to the target database, use the applied sub-command:

    $ dbgeni migrations applied

## Outstanding Migrations

To see all the migrations that have not been applied to the target database and are outstanding, use the outstanding sub-command:

    $ dbgeni migrations outstanding


## Apply Migrations

One of several apply sub-commands can be used to run the migration script against the target database. When a migration is run, the contents of the UP script are applied to the target database.

Normally migrations are applied in increasing TIMESTAMP order. Sometimes two different developers will add migrations that are out of sequence. The best way to correct this problem is to rename the files so the TIMESTAMPS put the files in the correct order.

### apply all

To apply all migrations that are outstanding, use the all command, eg:

    $ dbgeni migrations apply all

If there are no outstanding migrations or a problem is encountered applying a migration an error will be displayed and dbgeni will not continue.

### apply next

To apply only the next migration that is outstanding, use the next command, eg:

    $ dbgeni migrations apply next

If there are no outstanding migrations or a problem is encountered applying the migration an error will be displayed.

### apply specific

To apply a single or several migrations out of their normal sequence, you can specify specific migrations to apply on the command line, eg:

    $ dbgeni migrations apply 201108101531::create_users 201108110825::create_user_details 

If there are no outstanding migrations or a problem is encountered applying a migration an error will be displayed and dbgeni will not continue.

### Force Migrations Through

Normally when applying migrations, if any problem occurs applying a migration dbgeni stops processing it immediately, even if it is in the middle of a migration. Sometimes you just want to force a migration though, knowing some of the errors are not important. For all the migration commands, the --force (-f for short) switch can be specified with prevents dbgeni stopping when it encounters most errors, eg:

    $ dbgeni migrations apply all --force

## Rollback Migrations

When a migration is rolled back the contents of the DOWN script are applied to the target database. For rollbacks, the DOWN scripts are applied in *decending* timestamp order. There is a set of rollback commands that mirrors the migration apply commands.

### rollback all

To rollback everything, use the all sub-command. If things work correctly, this will remove the entire application from the database:

    $ dbgeni migrations rollback all

If there are no applied migrations or a problem is encountered rolling back a migration an error will be displayed and dbgeni will not continue.


### rollback last

To rollback just the last applied migration, use the last sub-command, eg:

    $ dbgeni migrations rollback last

If there are no applied migrations or a problem is encountered rolling back a migration an error will be displayed.

### rollback specific

To rollback a single or several migrations out of their normal sequence, you can specify specific migrations to rollback on the command line, eg:

    $ dbgeni migrations rollback 201108101531::create_users 201108110825::create_user_details 

If any of the migrations are not applied or a problem is encountered applying a migration an error will be displayed and dbgeni will not continue.

### Forcing Rollbacks

As with applying migrations, rollbacks can be forced through with the --force (-f for short) switch. This is particularly useful if an apply failed part way through and you want to clean up any changes it made.



## Installing Ruby

Version 1.9.2 is the best version of Ruby right now, but 1.8.7 will work fine too. 

Get the download for your platform and install it. For Windows, grab the [Ruby Installer](http://rubyinstaller.org/downloads/) and for other platforms have a look [here](http://rubygems.org/pages/download).

Next you need to install the Ruby Package manager, [RubyGems](http://rubygems.org/). 

[Download it]() and installed 
